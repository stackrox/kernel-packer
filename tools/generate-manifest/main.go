package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"regexp"
	"strconv"

	"gopkg.in/yaml.v2"

	"github.com/stackrox/kernel-packer/tools/config/manifest"
	"github.com/stackrox/kernel-packer/tools/config/reformat"
)

type ReformatterFunc func(packages []string) ([][]string, error)

var reformatters = map[string]ReformatterFunc{
	"one-to-each":  ReformatOneToEach,
	"one-to-pairs": ReformatOneToPairs,
	"pairs":        ReformatPairs,
	"single":       ReformatSingle,
}

func main() {
	if err := mainCmd(); err != nil {
		fmt.Fprintf(os.Stderr, "generate-manifest: %s\n", err.Error())
		os.Exit(1)
	}
}

func mainCmd() error {
	var (
		configFlag    = flag.String("config", "reformat.yml", "Config file containing reformat manifest.")
		inventoryFlag = flag.String("bucket-inventory-file", "", "File containing GCS object inventory.")
	)
	flag.Parse()

	var (
		configDir = path.Dir(*configFlag)
		cfg, err  = reformat.Load(*configFlag)
		builders  = make(manifest.Builders, len(*cfg))
	)

	bucketInventory, err := readInventory(*inventoryFlag)
	if err != nil {
		return err
	}

	for _, entry := range *cfg {
		pkgFile := path.Join(configDir, entry.File)

		packages, err := readPackagesFile(pkgFile)
		if err != nil {
			return err
		}

		reformatter := reformatters[entry.Reformat]
		packageSets, err := reformatter(packages)
		if err != nil {
			return err
		}

		builder := manifest.Builder{
			Description: entry.Description,
			Kind:        entry.Type,
			Packages:    make(map[string][]string, len(packageSets)),
		}

		for _, packages := range packageSets {
			packages = simplify(packages)

			// If any of the given packages do not exist in the bucket
			// inventory, do not add them to the manifest, as they don't exist,
			// and therefore cannot be built. Maybe they failed to download or
			// upload during the crawling phase.
			if missingFromBucketInventory(bucketInventory, packages) {
				continue
			}

			builder.Packages[manifest.ChecksumPackageNames(packages)] = packages
		}

		builders[entry.Name] = builder
	}

	rendered, err := yaml.Marshal(builders)
	if err != nil {
		return err
	}

	fmt.Println("# Code generated by running `make manifest`. DO NOT EDIT.")
	fmt.Println()
	fmt.Printf("%s\n", rendered)
	return nil
}

// ReformatOneToEach consumes a list of packages, and returns a list of package
// groups. Each package group is comprised of the first package listed, and is
// paired with every package in turn.
//
// For example:
// [a, b, c] → [[a, b], [a, c]]
func ReformatOneToEach(packages []string) ([][]string, error) {
	var (
		sets  = make([][]string, 0, len(packages))
		first = packages[0]
	)

	for _, pkg := range packages[1:] {
		set := []string{first, pkg}
		sets = append(sets, set)
	}

	return sets, nil
}

// ReformatOneToPairs consumes a list of packages, and returns a list of
// package groups. Each package group is comprised of the first package listed,
// and a triple is made with every pair of packages in turn.
//
// For example:
// [a, b, c, d, e] → [[a, b, c], [a, d, e]]
func ReformatOneToPairs(packages []string) ([][]string, error) {
	if len(packages) < 3 || len(packages)%2 == 0 {
		panic("bad package count")
	}
	var (
		sets  = make([][]string, 0, len(packages))
		first = packages[0]
	)

	for index := 1; index < len(packages); index += 2 {
		set := []string{first, packages[index], packages[index+1]}
		sets = append(sets, set)
	}

	return sets, nil
}

// ReformatPairs consumes a list of packages, and returns a list of package
// groups. Each package group is comprised of pairs of packages with the same
// version string. Packages with newer revisions will replace older revisions.
//
// For example: (Notice that the ".40" revision was dropped in favor of the ".50".)
// [4.4.0-1031.40_amd64, 4.4.0-1031.40_all, 4.4.0-1031.50_amd64, 4.4.0-1031.50_all, 4.4.0-1069.79_amd64, 4.4.0-1069.79_all] →
// [[4.4.0-1031.50_amd64, 4.4.0-1031.50_all], [4.4.0-1069.79_amd64, 4.4.0-1069.79_all]]
func ReformatPairs(packages []string) ([][]string, error) {
	type rev struct {
		packages []string
		revision int
	}

	var (
		manifests = make([][]string, 0, len(packages)/2)
		reVersion = regexp.MustCompile(`(\d+\.\d+\.\d+-\d+)\.(\d+)`)
		versions  = make(map[string]rev)
	)

	for _, pkg := range packages {
		matches := reVersion.FindStringSubmatch(pkg)
		// Matches should have exactly 3 items, the full match, the version,
		// and the revision number.
		// Ex: {"4.4.0-1006.6", "4.4.0-1006", "6"}
		if len(matches) != 3 {
			return nil, fmt.Errorf("regex failed to match")
		}

		version := matches[1]
		revision, err := strconv.Atoi(matches[2])
		if err != nil {
			panic(err)
		}

		r, found := versions[version]

		switch {
		case found && r.revision > revision:
			break
		case found && r.revision == revision:
			r.packages = append(r.packages, pkg)
		case found && r.revision < revision:
			r = rev{[]string{pkg}, revision}
		case !found:
			r = rev{[]string{pkg}, revision}
		}

		versions[version] = r
	}

	for _, rev := range versions {
		// Sanity check, there should always be a pair of packages.
		if len(rev.packages) != 2 {
			return nil, fmt.Errorf("unpaired package %v", packages)
		}

		manifests = append(manifests, rev.packages)
	}

	return manifests, nil
}

// ReformatSingle consumes a list of packages, and returns a list of package
// groups. Each package group is comprised of a single input package.
//
// For example:
// [a, b, c] → [[a], [b], [c]]
func ReformatSingle(packages []string) ([][]string, error) {
	var sets = make([][]string, 0, len(packages))

	for _, pkg := range packages {
		set := []string{pkg}
		sets = append(sets, set)
	}

	return sets, nil
}

// readPackagesFile reads the given file and returns a list of all non-empty lines.
func readPackagesFile(filename string) ([]string, error) {
	body, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	lines := bytes.Split(body, []byte("\n"))
	packages := make([]string, 0, len(lines))
	for _, line := range lines {
		line = bytes.TrimSpace(line)
		if len(line) > 0 {
			packages = append(packages, string(line))
		}
	}

	return packages, nil
}

func readInventory(filename string) (map[string]struct{}, error) {
	urls, err := readPackagesFile(filename)
	if err != nil {
		return nil, err
	}

	urlSet := make(map[string]struct{}, len(urls))
	for _, url := range urls {
		urlSet[url] = struct{}{}
	}

	return urlSet, nil
}

func simplify(urls []string) []string {
	var itemNames = make([]string, len(urls))
	for index, url := range urls {
		itemNames[index] = manifest.Simplify(url)
	}
	return itemNames
}

func missingFromBucketInventory(inventory map[string]struct{}, itemNames []string) bool {
	for _, itemName := range itemNames {
		if _, found := inventory[itemName]; !found {
			return true
		}
	}
	return false
}
