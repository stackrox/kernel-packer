package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"net/url"
	"os"
	"path"
	"regexp"

	"github.com/pkg/errors"

	"gopkg.in/yaml.v2"

	"github.com/stackrox/kernel-packer/tools/config/manifest"
	"github.com/stackrox/kernel-packer/tools/config/reformat"
	"github.com/stackrox/kernel-packer/tools/generate-manifest/reformatters"
	"github.com/stackrox/kernel-packer/tools/util"
)

func main() {
	if err := mainCmd(); err != nil {
		fmt.Fprintf(os.Stderr, "generate-manifest: %s\n", err.Error())
		os.Exit(1)
	}
}

func partitionURLs(urls []string) ([][]string, error) {
	urlsByHost := make(map[string][]string)
	for _, urlStr := range urls {
		// Probably not the best solution
		r := regexp.MustCompile(`.*https\:`)
		urlStr = r.ReplaceAllString(urlStr, "https:")
		u, err := url.Parse(urlStr)
		if err != nil {
			return nil, errors.Wrapf(err, "unparseable URL %q", urlStr)
		}
		hostURL := &url.URL{
			Scheme: u.Scheme,
			Host:   u.Host,
		}
		hostURLStr := hostURL.String()
		urlsByHost[hostURLStr] = append(urlsByHost[hostURLStr], urlStr)
	}

	// Kernel packages for older kops images are grouped with a kbuild package from a different host
	// (see crawl-kops target in kernel-crawler/Makefile)
	kopsKey := (&url.URL{Scheme: "http", Host: "dist.kope.io"}).String()
	if kopsURLs, ok := urlsByHost[kopsKey]; ok {
		kopsDebianKey := (&url.URL{Scheme: "http", Host: "http.us.debian.org"}).String()
		urlsByHost[kopsDebianKey] = append(urlsByHost[kopsDebianKey], kopsURLs...)
		delete(urlsByHost, kopsKey)
	}

	urlGroups := make([][]string, 0, len(urlsByHost))
	for _, urlGroup := range urlsByHost {
		urlGroups = append(urlGroups, urlGroup)
	}
	return urlGroups, nil
}

func mainCmd() error {
	var (
		configFlag    = flag.String("config", "reformat.yml", "Config file containing reformat manifest.")
		inventoryFlag = flag.String("bucket-inventory-file", "", "File containing GCS object inventory.")
	)
	flag.Parse()

	var (
		configDir = path.Dir(*configFlag)
		cfg, err  = reformat.Load(*configFlag)
	)
	if err != nil {
		return err
	}

	bucketInventory, err := readInventory(*inventoryFlag)
	if err != nil {
		return err
	}

	var mf = manifest.New()

	for _, entry := range *cfg {
		var (
			pkgFile          = path.Join(configDir, entry.File)
			reformatter, err = reformatters.Get(entry.Reformat)
		)
		if err != nil {
			return err
		}

		urls, err := readPackagesFile(pkgFile)
		if err != nil {
			return err
		}

		// Partition URLs by host
		urlGroups, err := partitionURLs(urls)
		if err != nil {
			return err
		}

		var allPackageSets [][]string
		for _, urlGroup := range urlGroups {
			// Split the given list of urls into a list of url groups. A given
			// group will contain 1-3 urls.
			packageSets, err := reformatter(urlGroup)
			if err != nil {
				return err
			}

			allPackageSets = append(allPackageSets, packageSets...)
		}

		for _, packages := range allPackageSets {
			// Transform the group of urls into a "simplified" group. This is
			// the naming convention used for storing objects in the GCS bucket.
			packages = util.SimplifyURLs(packages)

			// If any of the given urls do not exist in the bucket
			// inventory, do not add them to the manifest, as they don't exist,
			// and therefore cannot be built. Maybe they failed to download or
			// upload during the crawling phase.
			if missingFromBucketInventory(bucketInventory, packages) {
				continue
			}

			// Add a builder for the given kind and package group.
			mf.Add(entry.Type, packages)
		}
	}

	// Render the manifest as raw YAML.
	body, err := marshalHeader(mf)
	if body != "" {
		fmt.Print(body)
	}

	return err
}

// marshalHeader marshals the given object as YAML, and prepends a header
// comment to the beginning of the output.
func marshalHeader(in interface{}) (string, error) {
	var buf bytes.Buffer
	var body, err = yaml.Marshal(in)
	if err != nil {
		return "", err
	}

	buf.WriteString("# Code generated by running `make manifest`. DO NOT EDIT.\n")
	buf.Write(body)
	return buf.String(), nil
}

// readPackagesFile reads the given file and returns a list of all non-empty lines.
func readPackagesFile(filename string) ([]string, error) {
	body, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	lines := bytes.Split(body, []byte("\n"))
	packages := make([]string, 0, len(lines))
	for _, line := range lines {
		line = bytes.TrimSpace(line)
		if len(line) > 0 {
			packages = append(packages, string(line))
		}
	}

	return packages, nil
}

func readInventory(filename string) (map[string]struct{}, error) {
	urls, err := readPackagesFile(filename)
	if err != nil {
		return nil, err
	}

	urlSet := make(map[string]struct{}, len(urls))
	for _, url := range urls {
		urlSet[url] = struct{}{}
	}

	return urlSet, nil
}

func missingFromBucketInventory(inventory map[string]struct{}, itemNames []string) bool {
	for _, itemName := range itemNames {
		if _, found := inventory[itemName]; !found {
			return true
		}
	}
	return false
}
