#!/usr/bin/env bash
#
# Argument #1 - "Distro"
#   The name of a Linux distribution type. Used to invoke the corresponding
#   repackaging script that uses the correct package management tools, etc.
#
# Argument #2 - "Output Dir"
#   The name of a pre-existing, empty directory that can be written into. The
#   bundle tarball string for the kernel MUST be created inside of this
#   directory before returning. The bundle filename MUST be bundle-<version>.tgz.
#
# Argument #3...n - "Input File(s)"
#  The filenames of pre-existing files that MUST NOT be modified. The contents
#  of these files can be extracted/installed/etc in order to help build the
#  contents of the bundle File.

set -euo pipefail
IFS=$'\n\t'

main() {
    if [[ $# -lt 3 || $# -gt 5 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local distro="$1"
    local output_dir="$2"
    shift 2
    local packages=("$@")

    case "$distro" in
        CoreOS)
            log 'Repackaging CoreOS'
            repackage_coreos "$output_dir" "${packages[@]}"
        ;;

        Debian)
            log 'Repackaging Debian'
            repackage_debian "$output_dir" "${packages[@]}"
        ;;

        RedHat)
            log 'Repackaging RedHat'
            repackage_redhat "$output_dir" "${packages[@]}"
        ;;

        Ubuntu)
            log 'Repackaging Ubuntu'
            repackage_ubuntu "$output_dir" "${packages[@]}"
        ;;

        *)
            log 'unknown distro'
            return 1
        ;;
    esac
}

repackage_coreos() {
    if [[ $# -ne 2 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local output_dir="$1"
    local input_package="$2"

    # developer container is Bzip encoded, so extract it first.
    inflated_bundle="$(mktemp)"
    lbzip2 -dck "$input_package" > "$inflated_bundle"

    # Mount the extracted disk image on a loopback device.
    loop_device="$(kpartx -asvr "$inflated_bundle" | cut -d\  -f 3)"
    local tmp_dir="$(mktemp -d)"
    mount -r "/dev/mapper/${loop_device}" "$tmp_dir"

    (
        cd "$tmp_dir"

        # Find the name of the kernel directory. This directory will be used as the
        # root of the resulting archive.
        # Variable will contain a string that should looks like "4.13.9-coreos".
        local kernel_version="$(ls -1 "lib/modules" | head -n1)"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Compress only part of the file hierarchy into a tarball.
        printf './build' > /tmp/BUNDLE_BUILD_DIR
        tar --create --dereference --hard-dereference --file - \
            --directory "lib/modules/$kernel_version" ./build ./source \
            --directory /tmp ./BUNDLE_BUILD_DIR \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )

    # Clean up intermediate resources.
    umount "$tmp_dir"
    kpartx -dv "$inflated_bundle"
    rm -f "$inflated_bundle"
}

# Repackages two or three Debian DEB files into a bundle tarball.
repackage_debian() {
    if [[ $# -lt 3 || $# -gt 4 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local output_dir="$1"
    local input_package_1="$2"
    local input_package_2="$3"
    local input_package_3="${4:-}"

    # Create a temporary directory for extracting the DEB package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the DEB packages.
        dpkg -x "$input_package_1" .
        dpkg -x "$input_package_2" .
        if [[ -n "$input_package_3" ]]; then
            dpkg -x "$input_package_3" .
        fi

        # Find the name of the kernel directory.
        # Variable will contain a string that should looks like "4.4.39-k8s".
        local kernel_version="$(ls -1 "usr/src" | grep linux-headers | sed 's/linux-headers-//' | head -n1)"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Update symbolic links to be relative.
        ln --force --relative --symbolic "usr/src/linux-headers-${kernel_version}" "lib/modules/${kernel_version}/build"

        if [[ -n "$input_package_3" ]]; then
            # Update symbolic links to be relative.
            local common_dir="linux-headers-${kernel_version/amd64/common}"
            ln --force --relative --symbolic "usr/src/${common_dir}" "lib/modules/${kernel_version}/source"

            # Modify makefile arguments to work with relative paths.
            sed -i -e "s|^MAKEARGS :=.*$|MAKEARGS := -C ../${common_dir} O=\$(CURDIR)|g" \
                "usr/src/linux-headers-${kernel_version}/Makefile"
        fi

        # Compress the file hierarchy into a tarball.
        printf "./usr/src/linux-headers-%s" "$kernel_version" > /tmp/BUNDLE_BUILD_DIR
        tar --create --dereference --hard-dereference --file - \
            --directory "." ./usr ./lib \
            --directory /tmp ./BUNDLE_BUILD_DIR \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

# Repackages a single RedHat RPM file into a bundle tarball.
repackage_redhat() {
    if [[ $# -ne 2 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local output_dir="$1"
    local input_package="$2"

    # Create a temporary directory for extracting the RPM package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the RPM package tree.
        rpm2cpio "$input_package" | cpio -idm

        # Find the name of the kernel directory. This directory will be used as the
        # root of the resulting archive.
        # Variable will contain a string that should looks like "3.10.0-862.14.4.el7.x86_64".
        local kernel_version="$(ls -1 "usr/src/kernels" | head -n1)"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Compress only part of the file hierarchy into a tarball.
        printf '.' > /tmp/BUNDLE_BUILD_DIR
        tar --create --dereference --hard-dereference --file - \
            --directory "usr/src/kernels/${kernel_version}" . \
            --directory /tmp ./BUNDLE_BUILD_DIR \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

# Repackages two Ubuntu DEB files into a bundle tarball.
repackage_ubuntu() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local output_dir="$1"
    local input_package_1="$2"
    local input_package_2="$3"

    # Create a temporary directory for extracting the DEB package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the DEB packages.
        dpkg -x "$input_package_1" .
        dpkg -x "$input_package_2" .

        # Find the name of the kernel directory.
        # Variable will contain a string that should looks like "4.15.0-1023-aws".
        local kernel_version="$(ls -1 "usr/src" | grep linux-headers | sed 's/linux-headers-//' | grep -v generic | head -n1)"

        # One special case is that if there is a second directory that ends
        # with '-generic' we should favor that directory over the other.
        local kernel_version_generic="$(ls -1 "usr/src" | grep linux-headers | sed 's/linux-headers-//' | grep generic | head -n1)"
        if [[ -n "$kernel_version_generic" ]]; then
            kernel_version="$kernel_version_generic"
        fi

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Compress only part of the file hierarchy into a tarball.
        printf '.' > /tmp/BUNDLE_BUILD_DIR
        tar --create --dereference --hard-dereference --file - \
            --exclude ./scripts/dtc \
            --directory "usr/src/linux-headers-${kernel_version}" . \
            --directory /tmp ./BUNDLE_BUILD_DIR \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

log() {
    printf '%s\n' "$*" 1>&2
}

main "$@"
