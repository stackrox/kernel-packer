#!/usr/bin/env bash
#
# Argument #1 - "Distro"
#   The name of a Linux distribution type. Used to invoke the corresponding
#   repackaging script that uses the correct package management tools, etc.
#
# Argument #2 - "Output Dir"
#   The name of a pre-existing, empty directory that can be written into. The
#   bundle tarball string for the kernel MUST be created inside of this
#   directory before returning. The bundle filename MUST be bundle-<version>.tgz.
#
# Argument #3...n - "Input File(s)"
#  The filenames of pre-existing files that MUST NOT be modified. The contents
#  of these files can be extracted/installed/etc in order to help build the
#  contents of the bundle File.

set -euo pipefail
IFS=$'\n\t'

main() {
    if [[ $# -lt 4 || $# -gt 6 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local distro="$2"
    local output_dir="$3"
    shift 3
    local packages=("$@")

    case "$distro" in
        coreos)
            log 'Repackaging CoreOS'
            repackage_coreos "$checksum" "$output_dir" "${packages[@]}"
        ;;

        debian)
            log 'Repackaging Debian'
            repackage_debian "$checksum" "$output_dir" "${packages[@]}"
        ;;

        cos)
            log 'Repackaging Container-Optimized OS'
            repackage_cos "$checksum" "$output_dir" "${packages[@]}"
        ;;

        redhat)
            log 'Repackaging RedHat'
            repackage_redhat "$checksum" "$output_dir" "${packages[@]}"
        ;;

        ubuntu)
            log 'Repackaging Ubuntu'
            repackage_ubuntu "$checksum" "$output_dir" "${packages[@]}"
        ;;

        minikube)
            log 'Repackaging minikube disabled'
            return 0
            log 'Repackaging minikube'
            repackage_minikube "$checksum" "$output_dir" "${packages[@]}"
        ;;

        linuxkit)
            log 'Repackaging linuxkit'
            repackage_linuxkit "$checksum" "$output_dir" "${packages[@]}"
        ;;

        oracle)
        	log 'Repackaging oracle'
        	repackage_oracle "$checksum" "$output_dir" "${packages[@]}"
        ;;

        *)
            log 'unknown distro'
            return 1
        ;;
    esac
}

repackage_coreos() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package="$3"

    # developer container is Bzip encoded, so extract it first.
    inflated_bundle="$(mktemp)"
    lbzip2 -dck "$input_package" > "$inflated_bundle"

    # Mount the extracted disk image on a loopback device.
    loop_device="$(kpartx -asvr "$inflated_bundle" | cut -d\  -f 3)"
    local tmp_dir="$(mktemp -d)"
    mount -r "/dev/mapper/${loop_device}" "$tmp_dir"

    (
        cd "$tmp_dir"

        # Find the name of the kernel directory. This directory will be used as the
        # root of the resulting archive.
        # Variable will contain a string that should looks like "4.13.9-coreos".
        local kernel_version="$(ls -1 "lib/modules" | head -n1)"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'coreos' "$kernel_version" './build')"

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --directory "$meta_dir" . \
            --directory "${tmp_dir}/lib/modules/${kernel_version}" ./build ./source \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )

    # Clean up intermediate resources.
    umount "$tmp_dir"
    kpartx -dv "$inflated_bundle"
    rm -f "$inflated_bundle"
}

# Repackages two or three Debian DEB files into a bundle tarball.
repackage_debian() {
    if [[ $# -lt 4 || $# -gt 5 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package_1="$3"
    local input_package_2="$4"
    local input_package_3="${5:-}"

    # Create a temporary directory for extracting the DEB package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the DEB packages.
        dpkg -x "$input_package_1" .
        dpkg -x "$input_package_2" .
        if [[ -n "$input_package_3" ]]; then
            dpkg -x "$input_package_3" .
        fi

        # Find the name of the kernel directory.
        # Variable will contain a string that should looks like "4.4.39-k8s".
        local kernel_version="$(ls -1 "usr/src" | grep linux-headers | sed 's/linux-headers-//' | head -n1)"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Update symbolic links to be relative.
        ln --force --relative --symbolic "usr/src/linux-headers-${kernel_version}" "lib/modules/${kernel_version}/build"

        if [[ -n "$input_package_3" ]]; then
            # Update symbolic links to be relative.
            local common_dir="linux-headers-${kernel_version/amd64/common}"
            ln --force --relative --symbolic "usr/src/${common_dir}" "lib/modules/${kernel_version}/source"

            # Modify makefile arguments to work with relative paths.
            sed -i -e "s|^MAKEARGS :=.*$|MAKEARGS := -C ../${common_dir} O=\$(CURDIR)|g" \
                "usr/src/linux-headers-${kernel_version}/Makefile"
            find . -name 'Makefile' -type f -print0 | xargs -0 -n 1 sed -i -e 's|^include /|include $(BUILD_ROOT)/|g'
        fi

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'debian' "$kernel_version" "./usr/src/linux-headers-${kernel_version}")"

        # Compress the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --directory "$meta_dir" . \
            --directory "$tmp_dir" ./usr ./lib \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

repackage_cos() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package="$3"

    # Create a temporary directory for extracting the package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the package tree.
        tar -xf "$input_package"

        # Extract the build id from the cos package name it will be of the form,
        # 'https---storage.googleapis.com-cos-tools-10718.52.0-kernel-src.tar.gz'
        local build_id="$(echo "$input_package" | sed 's/^.*-\([0-9]\+\.[0-9]\+\.[0-9]\+\)-kernel-src\.tar\.gz$/\1/')"
        if [ -z $build_id ]; then 
            log "empty COS build id"
            return 1
        fi

        # Find the name of the kernel directory. This directory will be used as the
        # root of the resulting archive.
        # Variable will contain a string that should looks like "4.14.30+". Also, Notice the plus sign.
        local kernel_make_version="$(cat Makefile | grep '^VERSION ='    | head -n1 | cut -d ' ' -f 3)"
        local kernel_make_major="$(cat   Makefile | grep '^PATCHLEVEL =' | head -n1 | cut -d ' ' -f 3)"
        local kernel_make_minor="$(cat   Makefile | grep '^SUBLEVEL ='   | head -n1 | cut -d ' ' -f 3)"
        local kernel_version="${kernel_make_version}.${kernel_make_major}.${kernel_make_minor}"
        local kernel_uname="${kernel_version}+"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'cos' "${kernel_uname}" '.')"

        # Copy fixed kernel config 
        cp /etc/includes/cos/.config .

	sed -i 's/LOCALVERSION=""/LOCALVERSION="+"/' .config
	sed -i '/^#define randomized_struct_fields_start	struct {$/d' include/linux/compiler-clang.h
	sed -i '/^#define randomized_struct_fields_end	};$/d' include/linux/compiler-clang.h

        # Prepare kernel sources for module compilation
        make olddefconfig > /dev/null
        make modules_prepare > /dev/null

        # Delete all *.c files, excluding scripts directory
        find "${tmp_dir}" ! \( -type d \) -not -path "${tmp_dir}/scripts/*" -name "*.c" -delete

        local kernel_version_cos="${kernel_version}-${build_id}-cos"

        log "Kernel version is ${kernel_version_cos}"

        local bundle_path="${output_dir}/bundle-${kernel_version_cos}.tgz"

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --exclude ./Documentation \
            --directory "$meta_dir" . \
            --directory "${tmp_dir}" . \
        | pigz -9 -c > "${bundle_path}"
    )
}

# Repackages a single RedHat RPM file into a bundle tarball.
repackage_redhat() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package="$3"

    # Create a temporary directory for extracting the RPM package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the RPM package tree.
        rpm2cpio "$input_package" | cpio -idm

        # Find the name of the kernel directory. This directory will be used as the
        # root of the resulting archive.
        # Variable will contain a string that should looks like "3.10.0-862.14.4.el7.x86_64".
        local kernel_version="$(ls -1 "usr/src/kernels" | head -n1)"

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'redhat' "$kernel_version" '.')"

        # Remove broken symlinks.
        find "${tmp_dir}/usr/src/kernels/${kernel_version}" -type l -exec test ! -e {} \; -exec unlink {} \;

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --directory "$meta_dir" . \
            --directory "${tmp_dir}/usr/src/kernels/${kernel_version}" . \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

# Repackages two Ubuntu DEB files into a bundle tarball.
repackage_ubuntu() {
    if [[ $# -ne 4 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package_1="$3"
    local input_package_2="$4"

    # Create a temporary directory for extracting the DEB package tree.
    local tmp_dir="$(mktemp -d)"

    (
        cd "$tmp_dir"

        # Extract the DEB packages.
        dpkg -x "$input_package_1" .
        dpkg -x "$input_package_2" .

        # Find the name of the kernel directory.
        # Variable will contain a string that should looks like "4.15.0-1023-aws".
        local kernel_version="$(ls -1 "usr/src" | grep linux-headers | sed 's/linux-headers-//' | grep -v generic | head -n1)"

        # One special case is that if there is a second directory that ends
        # with '-generic' we should favor that directory over the other.
        local kernel_version_generic="$(ls -1 "usr/src" | grep linux-headers | sed 's/linux-headers-//' | grep generic | head -n1)"
        if [[ -n "$kernel_version_generic" ]]; then
            kernel_version="$kernel_version_generic"
        fi

        # Sanity check the derived kernel version.
        if [[ -z "$kernel_version" ]]; then
            log "blank kernel dir"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'ubuntu' "$kernel_version" '.')"

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --exclude ./scripts/dtc \
            --directory "$meta_dir" . \
            --directory "${tmp_dir}/usr/src/linux-headers-${kernel_version}" . \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

# Repackages a minikube kernel into a bundle tarball.
repackage_minikube() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package_1="$3"

    local minikube="$(mktemp -d)"
    local buildroot="${minikube}/out/buildroot"
    (
        tar --strip 1 -C "${minikube}" -xzf "${input_package_1}"
        cd "${minikube}"

        # extract buildroot
        sed -i '/$(MAKE) -C $(BUILD_DIR)\/buildroot/d' Makefile
        make minikube_iso &> /dev/null || true # error expected

        # extract kernel
        cd "${buildroot}"
        make linux-extract &> /dev/null

        local linux_src=$(find "${buildroot}/output/build" -maxdepth 1 -name 'linux-*' | head -n1)
        local kernel_version="$(echo "$linux_src" | sed -n 's/^.*\/linux-\([0-9]\+\.[0-9]\+\.[0-9]\+\)$/\1/p')"
        if [ ! -n "$kernel_version" ]; then
            kernel_version="$(echo "$linux_src" | sed 's/^.*\/linux-\([0-9]\+\.[0-9]\+\)$/\1/').0"
        fi

        if [[ -z "$kernel_version" ]]; then
            log "invalid kernel version"
            return 1
        fi
        log "Kernel version is $kernel_version"

        # config kernel, error expected
        make "${linux_src}/.config" &> /dev/null || true

        # prepare kernel
        cd "${linux_src}"
        make olddefconfig &> /dev/null
        make modules_prepare &> /dev/null

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'minikube' "$kernel_version" '.')"

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --directory "$meta_dir" . \
            --directory "${linux_src}" . \
        | pigz -9 -c > "${output_dir}/bundle-${kernel_version}.tgz"
    )
}

# Repackages a linuxkit kernel into a bundle tarball.
repackage_linuxkit() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package_1="$3"

    local linux_src="$(mktemp -d)"
    (
        tar --strip 1 -C "${linux_src}" -xzf "${input_package_1}"
        cd "${linux_src}"

        # Find the name of the kernel directory. This directory will be used as the
        # root of the resulting archive.
        # Variable will contain a string that should looks like "4.14.30+". Also, Notice the plus sign.
        local kernel_make_version="$(cat Makefile | grep '^VERSION ='    | head -n1 | cut -d ' ' -f 3)"
        local kernel_make_major="$(cat   Makefile | grep '^PATCHLEVEL =' | head -n1 | cut -d ' ' -f 3)"
        local kernel_make_minor="$(cat   Makefile | grep '^SUBLEVEL ='   | head -n1 | cut -d ' ' -f 3)"
        local kernel_version="${kernel_make_version}.${kernel_make_major}.${kernel_make_minor}"
        local kernel_uname="${kernel_version}-linuxkit"

        log "Kernel version is ${kernel_uname}"

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'linuxkit' "$kernel_uname" '.')"

        # Copy kernel config (see /etc/includes/linuxkit/README.md for details)
        cp /etc/includes/linuxkit/${kernel_version}-config .config

        # Prepare kernel sources for module compilation
        make olddefconfig > /dev/null
        make modules_prepare > /dev/null

        # Delete all *.c files, excluding scripts directory
        find "${linux_src}" ! \( -type d \) -not -path "${linux_src}/scripts/*" -name "*.c" -delete

        local bundle_path="${output_dir}/bundle-${kernel_uname}.tgz"

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
            --directory "$meta_dir" . \
            --directory "${linux_src}" . \
        | pigz -9 -c > "${bundle_path}"
    )
}

# Repackages a linuxkit kernel into a bundle tarball.
repackage_oracle() {
    if [[ $# -ne 3 ]]; then
        log "invalid number of arguments"
        return 1
    fi

    local checksum="$1"
    local output_dir="$2"
    local input_package_1="$3"

    local linux_src="$(mktemp -d)"
    (
    	cd "${linux_src}"
    	rpm2cpio "$input_package_1" | cpio -idm
    	kernel_src_dirs=(usr/src/kernels/*)
    	if [[ "${#kernel_src_dirs[@]}" -ne 1 ]]; then
    		log "More than one kernel source directory: ${kernel_src_dirs[*]}"
    		exit 1
    	fi
    	kernel_src_dir="${kernel_src_dirs[0]}"
    	kernel_uname="$(basename "$kernel_src_dir")"

    	cd "$kernel_src_dir"

        log "Kernel version is ${kernel_uname}"

        # Generate bundle meta files
        meta_dir="$(bundle_meta "$checksum" 'oracle' "$kernel_uname" '.')"

        # Delete all *.c files, excluding scripts directory
        find . ! \( -type d \) -not -path "./scripts/*" -name "*.c" -delete

        # Bogus symlink
        if [[ -L include/asm/asm && ! -d include/asm/asm ]]; then
        	ln -sf ../../arch/x86/include/asm include/asm/asm
        fi

        local bundle_path="${output_dir}/bundle-${kernel_uname}.tgz"

        # Compress only part of the file hierarchy into a tarball.
        tar --create --dereference --hard-dereference --file - \
        	--exclude ./scripts/dtc \
        	. \
            --directory "$meta_dir" . \
        | pigz -9 -c > "${bundle_path}"
    )
}

# Populates a temporary directory with files containing various pieces of
# bundle meta-information. All files are prefixed with 'BUNDLE_'.
bundle_meta() {
    local checksum="$1"
    local distro="$2"
    local kernel_uname="$3"
    local build_dir="$4"

    local kernel_version="$(echo "$kernel_uname" | sed 's/^\([0-9]\+\).*/\1/g')"
    local kernel_major="$(echo "$kernel_uname" | sed 's/^\([0-9]\+\)\.\([0-9]\+\).*/\2/g')"
    local kernel_minor="$(echo "$kernel_uname" | sed 's/^\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\).*/\3/g')"

    tmp_dir="$(mktemp -d)"

    echo -n "$checksum"       > "${tmp_dir}/BUNDLE_CHECKSUM"
    echo -n "$distro"         > "${tmp_dir}/BUNDLE_DISTRO"
    echo -n "$kernel_uname"   > "${tmp_dir}/BUNDLE_UNAME"
    echo -n "$kernel_version" > "${tmp_dir}/BUNDLE_VERSION"
    echo -n "$kernel_major"   > "${tmp_dir}/BUNDLE_MAJOR"
    echo -n "$kernel_minor"   > "${tmp_dir}/BUNDLE_MINOR"
    echo -n "$build_dir"      > "${tmp_dir}/BUNDLE_BUILD_DIR"

    echo "$tmp_dir"
}

log() {
    printf '%s\n' "$*" 1>&2
}

main "$@"
